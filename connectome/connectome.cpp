//TODO: something wrong with calculation of neuron outputs... they progress to true despite input after first tick
//TODO: verify connectome is crunching numbers properly, saveNewState is actually saving updated values, etc
//TODO: generate dataset of genetic cell weights for tuning
//TODO: write "glial code" that tunes weights closer to their "genetic values" based on whether initiated inputs created the expected output values

/*
ORDER OF STRETCH GOALS:

-weights initialized randomly between 0 and .1
-weights can be moved down to minimum of -.1
-weights are tuned constantly; if "genes" determine they need to be stronger or weaker, it adjusts via glia
-LTP and LTD are represented in cell synapses over short periods

-can abstract the effects of neuroglia into one "glial program"
-this program acts on the "guidepost genes" that tune the weights (strengthening = oligodendrocytes, weakening = microglia)
-later, differentiated glia can be added, including astrocytes, which synchronize nearby cells

-NT-R reactions can then be incorporated into weight calculation
-metabotropic transmitters/receptors can be made to have variable effects over time compared to the 'normal' ionotropic variety
-later, a gradient can be added to effects of metabotropic receptors on nearby cell's weights
*/

/*ultimately biologic "weight initialization" uses fuzzy logic...
   -randomness generated by who is nearest and how it affects weights
   -plus effect of oligodendrocytes
   -plus hebbian learning/LTP
   -plus LTD
   -plus the interaction of transmitters-receptors
   -plus effects of nearby transmitters-receptors

   we can approximate this with:
        -randomly initialized weights between 0 and .1
        -LTP/LTD funcitonality
        -neuroglia "gene guidepost" program to determine which weights to tune, how, and when based off of data sets on elegans synapse weights
        -NT-R reactions
        -gradient effects of metabotropic transmitters in 2d matrix
*/

//Authors: JoJo, Molly, Eonn, Kaiz - code created Dec. 2022


#include <iostream>
#include <fstream>
#include <string>
#include <algorithm>
#include <cstdlib>
#include "neuronIO.h"


/*
Getter function for a given neuron in the cellular matrix. Takes a cells ID, outputs the neuron object.
*/
neuron getNeuronFromMatrix(int targetID) {								//function to get the neuron out of the connectome object's cellular matrix
  return c.cellularMatrix[targetID];
}

/*
Getter function for the threshold of a given neuron in the matrix. Takes a cells ID, outputs the integer threshold.
*/
int getCellThresholdFromMatrix(int targetID) {
   return c.cellularMatrix[targetID].threshold;
}

/*
Getter function for the output of a given neuron in the matrix. Takes a cells ID, outputs a boolean value.
*/
bool getCellOutputFromMatrix(int targetID) {
   return c.cellularMatrix[targetID].cellOutput;
}

/*
Getter function for the length of a cells input array. Takes a cells ID, outputs an integer length.
*/
int getCellInputLenFromMatrix(int targetID) {
   return c.cellularMatrix[targetID].inputsLen;
}

/*
Getter function for the input array of a given cell. Takes a cells ID, outputs an array of the input IDs.
*/
int* getCellInputsFromMatrix(int targetID) {
   return c.cellularMatrix[targetID].inputs;
}

/*
Getter function for the length of a cells weight array. Takes a cells ID, outputs an integer length.
*/
int getCellWeightLenFromMatrix(int targetID) {
   return c.cellularMatrix[targetID].weightsLen;
}

/*
Getter function for the weight array of a given cell. Takes a cells ID, outputs an array of the weight values.
*/
float* getCellWeightsFromMatrix(int targetID) {
   return c.cellularMatrix[targetID].weights;
}

/*
Function to print the entire matrix of cells.
*/
void printCellularMatrix() {
    int width = 17;
    int height = 18;
    int neuronCounter = 1;

        for (int i = 0; i < height; i++) {
            for (int k = 0; k < width; k++) {
                if (neuronCounter < neuronCount) {
                    if (c.cellularMatrix[neuronCounter].cellOutput) {
                        cout << "[1]";
                    } else {
                        cout << "[0]";
                    }

                    neuronCounter++;
                }
            }
            cout << '\n';
        }

    cout << '\n';
}

/*
Function to calculate if a given cell fires. Takes a cells ID, outputs a boolean activation value.
*/
bool activationFunction (int cellID) {          	                    //activation function calculator-- it tells you what output the weighted inputs into the given neuron make
    float finalSummation = 0.0;                                         //initalize function to hold final sum(Xi * Wi)
    float neuronWeights[maxSynapse] = {*c.cellularMatrix->weights};     //make a matrix to hold all cell weights for a given neuron
    float productMatrix[neuronCount];                                   //make a maktrix to hold all multiplied sums
    int neuronInputs[maxSynapse] = {*c.cellularMatrix->inputs};         //make a matrix to hold all cell input IDs for a given neurons presynapses
    int inputLen = getCellInputLenFromMatrix(cellID);                   //get the length of the input and weight matrix for a given neuron

    bool inputValues[inputLen] = {};                                    //make an array to hold all boolean values for each presynaptic neuron input

    for (int i = 0; i < inputLen; i++) {                                //iterate over the length of presynaptic inputs
        inputValues[i] = getCellOutputFromMatrix(neuronInputs[i]);      //fill the presynaptic boolean matrix with every output value for each presynaptic neuron
    }

    for (int i = 0; i < maxSynapse; i++) {                              //iterate over all possible connections
        productMatrix[i] = neuronWeights[i] * inputValues[i];           //fill a matrix with the product of the Wi and Xi values
    }

    for (int i = 0; i < inputLen; i++) {		                        //iterate over the length of presynaptic inputs
        finalSummation += productMatrix[i];		                        //for every input add the product matrix to a running sum
    }

    if (finalSummation < getNeuronFromMatrix(cellID).threshold) {       //if the running sum is less than the given neurons threshold
        return false;                                                   //return false
    } else {                                                            //otherwise
        return true;                                                    //return true
    }
}

/*
FUNCTION DEFUNCT IN CURRENT ARCHITECTURE
Function to update the input synapses of other neurons connected to a given neuron. Takes a cells ID and the output value to be passed around.

void updateInputArray(int targetNeuronID, bool outputVal) {				//update synapses of other neurons based on post-synaptic value of given neuron
	for (int i = 0; i < neuronCount; i++) {						        //for every cell in the connectome
        int length = getCellInputLenFromMatrix(targetNeuronID);
		for (int j = 0; j < length; j++) {		                        //and every input of the target neuron
			if (getNeuronFromMatrix(i).inputs[j] == targetNeuronID) {	//check to see if the input cells correspond to the target neuron
                getNeuronFromMatrix(i).inputs[j] = outputVal;           //if they do, update its value to be the new output value
			}
		}
	}
}*/

/*
Function to update the output arrays of neurons. Takes a cells ID and the output to be updated.
*/
void updateOutputArray(int cellID, bool outputVal) {
    c.cellularMatrix[cellID].cellOutput = outputVal;
}

/*
Function to set the next tick of the connectome.
*/
void setNextState() {                  			        //function to update values in connectome to next state using the activation function
  for (int i = 0; i < neuronCount; i++) {		        //for every cell in the connectome
      bool activationVal = activationFunction(i);

      if (activationVal) {						        //if the activation function of that cell returns true
          c.outputs[i] = 1;								//save its output in the connectomes output matrix as true
//          updateInputArray(i, 1);						//update the rest of the cells that use that output value in the connectome
	      updateOutputArray(i, 1);						//update the individual output value for that cell in the cells struct as well (not just in the connectomes matrix)
       } else {
          c.outputs[i] = 0;								//otherwise save it as false
//          updateInputArray(i, 0);						//update the rest of the cells that use that output value in the connectome
	      updateOutputArray(i, 0);						//update the individual output value for that cell in the cells struct as well (not just in the connectomes matrix)
       }
  }
}

/*
Function to save the current state of the connectomes cellular matrix to the matrix file.
*/
void saveNewState() {
    for (int i = 0; i < neuronCount; i++) {             //for every cell in the connectome
        neuronToString(getNeuronFromMatrix(i));         //call a function to write its data to a file
    }
}

/*
Main function that runs connectome in a loop
*/
int main() {
    for (int i = 1; i <= neuronCount; i++) {    //for every neuron in the network
        c.cellularMatrix[i] = neuralList[i];    //load the neuron from a file into the matrix of the connectome
    }

    bool activated = true;                      //declare a boolean to set connectome as 'on'

    while (activated) {                         //while it's true run the connectome
        getSensoryInputs();                     //get updated sensory information from a file

        printCellularMatrix();                  //print the connectome out
        cout << '\n';

        printMotorMatrix();                     //print the motor cell matrix out
        cout << '\n';

        setNextState();                         //calculate next state of the connectome
        saveNewState();                         //save the state of the connectome
    }

    return 0;
}
