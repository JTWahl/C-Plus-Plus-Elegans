//Authors: JoJo, Molly, Eonn, Kaiz - code created Dec. 2022

//TODO: fix neuronToString() and use it to save new values to the matrix txt every tick
//TODO: get printMotorOutput() to actually print to the file

//TODO: generate large .txt file with neuron struct information
//TODO: verify random weights are actually at proper values
//TODO: generate dataset of genetic cell weights for tuning
//TODO: write "glial code" that tunes weights closer to their values based on whether initiated inputs caused their expected output values



/*
ORDER OF STRETCH GOALS:

-weights initialized randomly between 0 and .1 (can use any found data sets as seed values for this)
-weights can be moved down to minimum of -.1
-weights are tuned constantly; if "genes" determine they need to be stronger or weaker, it adjusts via glia
-LTP and LTD are represented in cell synapses over short periods

-can abstract the effects of neuroglia into one "glial program"
-this program acts on the "guidepost genes" that tune the weights (strengthening = oligodendrocytes, weakening = microglia)
-later, differentiated glia can be added, including astrocytes, which synchronize nearby cells

-NT-R reactions can then be incorporated into weight calculation
-metabotropic transmitters/receptors can be made to have variable effects over time compared to the 'normal' ionotropic variety
-later, a gradient can be added to effects of metabotropic receptors on nearby cell's weights
*/

/*ultimately biologic "weight initialization" uses fuzzy logic...
   -randomness generated by who is nearest and how it affects weights
   -plus effect of oligodendrocytes
   -plus hebbian learning/LTP
   -plus LTD
   -plus the interaction of transmitters-receptors
   -plus effects of nearby transmitters-receptors

   we can approximate this with:
        -randomly initialized weights between 0 and .1
        -LTP/LTD funcitonality
        -neuroglia "gene guidepost" program to determine which weights to tune, how, and when based off of data sets on elegans synapse weights
        -NT-R reactions
        -gradient effects of metabotropic transmitters in 2d matrix
*/


#include <iostream>
#include <fstream>
#include <string>
#include <algorithm>
#include <cstdlib>
#include <ctime>
#include "neuronIO.h"


neuron getNeuronFromMatrix(int targetID) {								//function to get the neuron out of the connectome object's cellular matrix
  return c.cellularMatrix[targetID];
/*	for (int i = 0; i < neuronCount - 1; i++) {		//for every cell in the matrix
		neuron currentCell = c.cellularMatrix[i];				//make a copy of each cell and set it to a temporary variable
		if (currentCell.cellID == targetID) {							//if the temporary cell's ID is the same as the target
			return c.cellularMatrix[i];						//return the cell from the connectome's matrix
		}
   }
   return c.cellularMatrix[1];*/
}

int getCellThresholdFromMatrix(int targetID) {
	/*for (int i = 0; i < neuronCount - 1; i++) {		//for every cell in the matrix
		neuron currentCell = c.cellularMatrix[i];				//make a copy of each cell and set it to a temporary variable
		if (currentCell.cellID == targetID) {							//if the temporary cell's ID is the same as the target
			return c.cellularMatrix[i].threshold;				//return the threshold value of the cell from the connectome's matrix
		}
   }
   return 0;*/
   return c.cellularMatrix[targetID].threshold;
}

bool getCellOutputFromMatrix(int targetID) {
/*	for (int i = 0; i < neuronCount - 1; i++) {		//for every cell in the matrix
		neuron currentCell = c.cellularMatrix[i];				//make a copy of each cell and set it to a temporary variable
		if (currentCell.cellID == targetID) {							//if the temporary cell's ID is the same as the target
			return c.cellularMatrix[i].cellOutput;				//return the output value of the cell from the connectome's matrix
		}
   }
   return 0;*/
   return c.cellularMatrix[targetID].cellOutput;
}

int getCellInputLenFromMatrix(int targetID) {
/*	for (int i = 0; i < neuronCount - 1; i++) {		//for every cell in the matrix
		neuron currentCell = c.cellularMatrix[i];				//make a copy of each cell and set it to a temporary variable
		if (currentCell.cellID == targetID) {							//if the temporary cell's ID is the same as the target
			return c.cellularMatrix[i].inputsLen;				//return the length of the matrix of inputs of the cell from the connectome's matrix
		}
   }
   return 0;*/
   return c.cellularMatrix[targetID].inputsLen;
}

int* getCellInputsFromMatrix(int targetID) {
/*	for (int i = 0; i < neuronCount - 1; i++) {		                //for every cell in the matrix
		neuron currentCell = c.cellularMatrix[i];				//make a copy of each cell and set it to a temporary variable
		if (currentCell.cellID == targetID) {                   //if the temporary cell's ID is the same as the target
			return c.cellularMatrix[i].inputs;     				//return the matrix of inputs of the cell from the connectome's matrix
		}
    }
   return 0;*/
   return c.cellularMatrix[targetID].inputs;
}

int getCellWeightLenFromMatrix(int targetID) {
 /*   for (int i = 0; i < neuronCount - 1; i++) {		//for every cell in the matrix
		neuron currentCell = c.cellularMatrix[i];				//make a copy of each cell and set it to a temporary variable
		if (currentCell.cellID == targetID) {							//if the temporary cell's ID is the same as the target
			return c.cellularMatrix[i].weightsLen;				//return the length of the matrix of inputs of the cell from the connectome's matrix
		}
   }
   return 0;*/
   return c.cellularMatrix[targetID].weightsLen;
}

float* getCellWeightsFromMatrix(int targetID) {
/*	for (int i = 0; i < neuronCount - 1; i++) {		//for every cell in the matrix
		neuron currentCell = c.cellularMatrix[i];				//make a copy of each cell and set it to a temporary variable
		if (currentCell.cellID == targetID) {							//if the temporary cell's ID is the same as the target
			return c.cellularMatrix[i].weights;				//return the matrix of weights of the cell from the connectome's matrix
		}
   }
   return 0;*/
   return c.cellularMatrix[targetID].weights;
}

void initWeights() {
    srand (static_cast <unsigned> (time(0)));

    for (int i = 0; i < neuronCount; i++) {
        for (int j = 0; j < c.cellularMatrix[i].weightsLen; j++) {
            float randomWeight = static_cast <float> (rand()) / static_cast <float> (RAND_MAX);
            c.cellularMatrix[i].weights[j] = randomWeight/10;
        }
    }
}

void printCellularMatrix() {
    int width = 17;
    int height = 18;
    int neuronCounter = 0;

    cout << '\n';

        for (int i = 0; i < height; i++) {
            for (int k = 0; k < width; k++) {
                if (neuronCounter < neuronCount) {
                    bool outputState = getCellOutputFromMatrix(neuronCounter);

                    if (outputState) {
                        cout << "[1]";
                    } else {
                        cout << "[0]";
                    }

                    neuronCounter++;
                }
            }
            cout << '\n';
        }

    cout << '\n';
}

bool activationFunction (int cellID) {          	//activation function calculator-- it tells you what output the weighted inputs into the given neuron make
   float finalSummation = 0.0;
   float neuronWeights[neuronCount] = {*c.cellularMatrix->weights};
   int neuronInputs[neuronCount] = {*c.cellularMatrix->inputs};

   float summationMatrix[neuronCount];	//multiply the input matrix by the weights matrix

   for (int i = 0; i < neuronCount - 1; i++) {
        summationMatrix[i] = neuronWeights[i] * neuronInputs[i];
   }

   for (int i = 0; i < getCellInputLenFromMatrix(cellID); i++) {		//for every input
         finalSummation = finalSummation + summationMatrix[i];										//add their product to the running sum
    }

   return finalSummation > getCellThresholdFromMatrix(cellID);					//if the running sum exceeds the cells threshold return true, else return false
}

void updateInputArray(int targetNeuronID, bool outputVal) {								//update synapses of other neurons based on post-synaptic value of given neuron
	for (int i = 0; i < neuronCount; i++) {						//for every cell in the connectome
        int length = getCellInputLenFromMatrix(targetNeuronID);
		for (int j = 0; j < length; j++) {		//and every input of the target neuron
			if (getNeuronFromMatrix(i).inputs[j] == targetNeuronID) {		//check to see if the input cells correspond to the target neuron
                getNeuronFromMatrix(i).inputs[j] = outputVal;   //if they do, update its value to be the new output value
			}
		}
	}
}

void updateOutputArray(int cellID, bool outputVal) {
    c.cellularMatrix[cellID].cellOutput = outputVal;
}

void setNextState() {                  			//function to update values in connectome to next state using the activation function
  for (int i = 1; i < neuronCount; i++) {					//for every cell in the connectome

      bool activationVal = activationFunction(i);
      if (activationVal) {						//if the activation function of that cell returns true
          c.outputs[i] = 1;									//save its output in the connectomes output matrix as true
          updateInputArray(i, 1);						//update the rest of the cells that use that output value in the connectome
	      updateOutputArray(i, 1);						//update the individual output value for that cell in the cells struct as well (not just in the connectomes matrix)

       } else {
          c.outputs[i] = 0;									//otherwise save it as false
          updateInputArray(i, 0);						//update the rest of the cells that use that output value in the connectome
	      updateOutputArray(i, 0);						//update the individual output value for that cell in the cells struct as well (not just in the connectomes matrix)
       }
  }
}

void saveNewState() {
    for (int i = 0; i < neuronCount; i++) {
        neuronToString(getNeuronFromMatrix(i));
    }
}

int main() {
    initWeights();

    for (int i = 1; i < neuronCount; i++) {
        c.cellularMatrix[i] = neuralList[i];
    }

    bool activated = true;


    while (activated) {
        getSensoryInputs();

        printCellularMatrix();
        cout << '\n';

        printMotorMatrix();
        cout << '\n';

        setNextState();
        saveNewState();
    }

    return 0;
}
